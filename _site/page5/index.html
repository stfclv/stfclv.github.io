<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      stf &bull; out &middot; KB with instant search
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/stfclv.github.io/public/css/poole.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/syntax.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/hyde.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/algolia.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/stfclv.github.io/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/stfclv.github.io/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-08">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/stfclv.github.io/">
          stf &bull; out
        </a>
      </h1>
      <p class="lead">My personal knowledge base, blog notes and thoughts on top of the popular <a href="http://hyde.getpoole.com/" target="_blank">Hyde</a> &hearts; <a href="http://jekyllrb.com" target="_blank">Jekyll</a>. Made by <a href="https://twitter.com/stefun_" target="_blank">@stefun_</a>, Solutions Architect <a href="http://www.cloudera.com" target="_blank">@Cloudera</a>.</a></p>
    </div>

    <input type="text" class="algolia__input js-algolia__input" autocomplete="off" name="query" placeholder="Search in this site..." />

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/stfclv.github.io/">Home</a>

      

      
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/security/">Security</a>
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/tricks/">Trixx</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/stfclv/stfclv.github.io">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2018. All rights reserved. Original by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> and <a href="https://www.algolia.com/" target="_blank">Algolia</a>.</p>
  </div>
</div>


    <div class="content container">
      <div class="algolia__initial-content js-algolia__initial-content"><div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/06/05/popular-misperceptions-search-service/">
        Common Misperceptions about Search as a Service
      </a>
    </h1>

    <span class="post-date">05 Jun 2014</span>

    <p>Since the first SaaS IPO by <a href="http://www.salesforce.com/">salesforce.com</a>, the
SaaS (Software as a Service) model has boomed in the last decade to become a
global market that is worth billions today. It has taken a long way and a lot
of evangelisation to get there.</p>

<p>Before <a href="http://www.salesforce.com/">salesforce.com</a> and the other SaaS
pioneers succeeded at making SaaS a standard model, the IT departments were
clear: the infrastructure as well as the whole stack had to be behind their
walls. Since then, mindsets have shifted with the cloud revolution, and you
can now find several softwares such as Box, Jive or Workday used by a lot of
Fortune 500 companies and millions of SMBs and startups.</p>

<p>Everything is now going SaaS, even core product components such as internal
search. This new generation of SaaS products is facing the same misperceptions
their peers faced years ago. So today, we wanted to dig into the
misperceptions about search as a service in general.</p>

<h2>Hosting your search is way more complex and expensive than you may think</h2>

<p>Some people prefer to go on-premises as they only pay for the raw resource,
especially if they choose to run open source software on it. By doing this,
they believe they can skip the margin layer in the price of the SaaS
solutions. The problem is that this view highly under-estimates the Total Cost
of Ownership (TCO) of the final solution.</p>

<p>Here are some reasons why hosting your own search engine can get extremely
complex &amp; expensive:</p>

<h3>Hardware selection</h3>

<p>A search engine has the particularity of being very IO (indexing), RAM
(search) and CPU (indexing + search) intensive. If you want to host it
yourself, you need to make sure your hardware is well sized for the kind of
search you will be handling. We often see companies that run on under-sized
EC2 instances to host their search engine are simply unable to add more
resource-consuming features (faceting, spellchecking, auto-completion).
Selecting the right instance is more difficult than it seems, and you&#39;ll need
to review your copy if your dataset, feature list or queries per second (QPS)
change. Elasticity is not only about adding more servers, but is also about
being able to add end-users features. Each Algolia cluster is backed by 3
high-end bare metal servers with at least the following hardware
configuration:</p>

<ul>
<li><strong>CPU</strong>: Intel Xeon (E5-1650v2) 6c/12t 3,5 GHz+/3,9 GHz+</li>
<li><strong>RAM</strong>: 128GB DDR3 ECC 1600MHz</li>
<li><strong>Disk</strong>:  1.2TB  SSD (via 3 or 4 high-durability SSD disks in RAID-0)</li>
</ul>

<p>This configuration is key to provide instant and realtime search, answering
queries in &lt;10ms.</p>

<h3>Server configuration</h3>

<p>It is a general perception of many technical people that server configuration
is easy: after all it should just be a matter of selecting the right EC2
Amazon Machine Image (AMI) + a puppet/chef configuration, right?
Unfortunately, this isn&#39;t the case for a search engine. Nearly all AMIs
contain standard kernel settings that are okay if you have low traffic, but a
<strong>nightmare</strong> as soon as your traffic gets heavier. We&#39;ve been working with
search engines for the last 10 years, and we still discover kernel/hardware
corner cases every month! To give you a taste of some heavyweight issues
you&#39;ll encounter, check out the following bullet points:</p>

<ul>
<li><strong>IO</strong>: Default kernel settings are <strong>NOT</strong> optimized for SSDs!!! For example, Linux&#39;s I/O scheduler is configured to merge some I/Os to reduce the hard-drive latency while seeking the disk sectors: non-sense on SSD and slowing the overall server performance.</li>
<li><strong>Memory</strong>: The kernel caches a lot, and that&#39;s cool... most of the time. When you write data on the disk, it will actually be written in the RAM and flushed to disk later by the pdflush process. There are some advanced kernel parameters that allow configuration. vm.dirty<em>background</em>ratio is one of them: it configures the maximum percentage of memory that can be &quot;dirty&quot; (in cache) before it is written on the disk.  In other words, if you have 128GB of RAM, and you are using the default value of 10% for dirty<em>background</em>ratio, the system will only flush the cache when it reaches 12GB!!!! Flushing such bursts of writes will <strong>slow down your entire system</strong> (even on SSD), killing the speed of all searches &amp; reads. <a href="http://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">Read more</a>.</li>
<li><strong>Network</strong>:  When calling the listen function in BSD and POSIX sockets, an argument called the backlog is accepted. The backlog argument defines the maximum length of the queue of pending connections for sockfd. If the backlog argument is higher than the value in net.core.somaxconn, it is silently truncated to that value. The default value is 128 which is <strong>way too low</strong>! If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED. <a href="http://engineering.chartbeat.com/2014/01/02/part-1-lessons-learned-tuning-tcp-and-nginx-in-ec2/">Read more</a> &amp; <a href="https://www.youtube.com/watch?v=yL4Q7D4ynxU">even more</a>.</li>
</ul>

<p>We&#39;ve been working hard to fine-tune such settings and it has allowed us to
handle today several thousands of search operations per second on one server.</p>

<h3>Deployment &amp; upgrades are complex</h3>

<p>Upgrading software is one of the main reasons of service outages. It should be
fully automated and capable of rolling back in case of a deployment failure.
If you want to have a safe deployment, you would also need a pre-production
setup that duplicates your production&#39;s setup to validate a new deployment, as
well as an A/B test with a part of your traffic. Obviously, such setup
requires additional servers. At Algolia, we have test and pre-production
servers allowing us to validate every deployment before upgrading your
production cluster. Each time a feature is added or a bug is fixed on the
engine, all of our clusters are updated so that everyone benefits from the
upgrade.</p>

<h3>Toolbox vs features</h3>

<p>On-premises solutions were not built to be exposed as a public service: you
always need to build extra layers on top of it. And even if these solutions
have plenty of APIs and low-level features, turning them into end-user
features requires time, resources and a lot of engineering (more than just a
full-stack developer!). You may need to re-develop:</p>

<ul>
<li>*<em>**Auto-completion</em><em>:</em>* to suggest best products/queries directly from the search bar while handling security &amp; business filters (not only suggesting popular entries);</li>
<li><strong>Instant-Faceting:</strong> to provide realtime faceting refreshed at each keystroke;</li>
<li>*<em>**Multi-datacenter replication</em><em>:</em>* synchronize your data across multiple instances and route the queries to the right datacenter to ensure the best search performance all around the world;</li>
<li><strong>Queries analytics</strong>: to get valuable information on what and how people search;</li>
<li><strong>Monitoring</strong>: To track in realtime the state of your servers, the storage you use, the available memory, the performance of your service, etc.</li>
</ul>

<h2>On-premises is not as secure as one might think</h2>

<p>Securing a search engine is very complex and if you chose to do it yourself,
you will face three main challenges:</p>

<ol>
<li> <strong>Controlling who can access your data</strong>: You probably have a model that requires permissions associated with your content. Search as a service providers offer packaged features to handle user based restrictions. For example you can generate an API Key that can only target specific indexes. Most on-premise search engines do not provide any access control feature.</li>
<li><strong>Protecting yourself against attacks</strong>: There are various attacks that your service can suffer from (denial of service, buffer overflow, access control weakness, code injection, etc.). API SaaS providers put a lot of effort into having the best possible security. For example API providers reacted the most quickly to the &quot;HeartBleed&quot; SSL vulnerability; It only took a few hours after disclosure for <a href="https://www.twilio.com/blog/2014/04/customer-security-notice-on-cve-2014-0160-heartbleed-disclosure.html">Twilio</a>, <a href="https://www.firebase.com/blog/2014-04-08-open-ssl-security-update.html">Firebase</a> and <a href="http://blog.algolia.com/dealing-openssl-security-issue/">Algolia</a> to fix the issue.</li>
<li><strong>Protecting yourself from unwarranted downloads:</strong> The search feature of your website can easily expose a way to grab all your data. Search as a service providers offer packaged features to help prevent this problem (rate limit, time-limited API Key, user-restricted API Key, etc.).</li>
</ol>

<p>Mastering these three areas is difficult, and API providers are challenged
every day by their customers to provide a state-of-the-art level of security
in all of them. Reaching the same level of security with an on-premise
solution would simply require too much investment.</p>

<h2>Search as a service is not reserved to simple use cases</h2>

<p>People tend to believe that search as a service is only good for basic use
cases, which prevents developers from implementing fully featured search
experiences. The fact of the matter is that search as a service simply handles
all of the heavy lifting while keeping the flexibility to easily configure the
engine. Therefore it enables any developers, even front-end only developers,
to build complex instant search implementation with filters, faceting or geo-
search. For instance, feel free to take a look at
<a href="http://jadopado.com">JadoPado</a>, a customer who developed a fully featured
instant search for their e-commerce store. Because your solution runs inside
your walls once in production,  you will need a dedicated team to constantly
track and fix the multiple issues you will encounter. Who would think of
having a team dedicated to ensuring their CRM software works fine? It makes no
sense if you use a SaaS software like most people do today. Why should it make
more sense for components such as search? All the heavy lifting and the
operational costs are now concentrated in the SaaS providers&#39; hands, making it
eventually way more cost-efficient for you..</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/05/22/synonym-search-engine/">
        A New Way to Handle Synonyms in a Search Engine
      </a>
    </h1>

    <span class="post-date">22 May 2014</span>

    <p>We recently added the support for Synonyms in Algolia! It has been the most
requested feature in Algolia since our launch in September. While it may seem
simple, it actually took us some time to implement because we wanted to do it
in a different way than classic search engines.</p>

<h2>What&#39;s wrong with synonyms</h2>

<p>There are two main problems with how existing search engines handle synonyms.
These issues disturb the user experience and could make them think <em>&quot;this
search engine is buggy&quot;</em>.</p>

<h3>Typeahead</h3>

<p>In most search engines, synonyms are not compatible with typeahead search. For
example, if you want tablet  to equal  ipad in a query, the prefix search for
t , ta , tab , tabl  &amp; table  will not trigger the expansion on iPad ; Only
the tablet query will. Thus, a single new letter in the search bar could
totally change the result set, catching users off-guard.</p>

<h3>Highlighting</h3>

<p>Highlighting matched text is a key element of the user experience, especially
when the search engine tolerates typos. This is the difference between making
users think <em>&quot;I don&#39;t understand this result&quot;</em> and <em>&quot;This engine was able to
understand my errors&quot;</em>. Synonym expansions are rarely highlighted, which
breaks the trust of the users in the search results and can feel like a bug.</p>

<h2>Our implementation</h2>

<p>We have identified two different use cases for synonyms: equalities and
placeholders. The first and most common use case is when you tell the search
engine that several words must be considered equal, for example st and street
in an address. The second use case, which we call a <em>placeholder</em>, is when you
indicate that a specific token can be replaced by a set of possible words and
that the token itself is not searchable. For example, the content <number>
street could be matched by the queries 1st street or 2nd street but not the
query number street.</p>

<p>For the first use case, we have added a support of synonyms that is compatible
with prefix search and have implemented two different ways to do highlighting
(controlled by thereplaceSynonymsInHighlight  query parameter):</p>

<ol>
<li>A mode where the original word that matched via a synonym is highlighted. For example if you have a record that contains black ipad 64GB  and a synonym black equals dark, then the following queries will fully highlight the black word : ipad d , ipad da , ipad dar &amp; ipad dark. The typeahead search is working and the synonym expansion is fully highlighted: <code>**black** **ipad** 64GB</code> .</li>
<li>A mode where the original word is replaced by the synonym, and the matched prefix is highlighted. For example ipad d  query will replace black by dark and will highlight the first letter of dark: <code>**d**ark **ipad** 64GB</code>. This method allows to fully explain the results when the original word can be safely replaced by the matched synonym.</li>
</ol>

<p>For the second use case, we have added support for placeholders. You can add a
specific token in your records that will be safely replaced by a set of words
defined in your configuration. The highlighting mode that replaces the
original word by the expansion totally makes sense here. For example if you
have <streetnumber> mission street  record with a placeholder <streetnumber> =
[ &quot;1st&quot;, &quot;2nd&quot;, ....] , then the query 1st missionstreet will replace <number>
by 1st  and will highlight all words: <code>**1st mission street**</code>.</p>

<p>We believe this is a better way to handle synonyms and we hope you will like
it :) We would love to get your feedback and ideas for improvement on this
feature! Feel free to contact us at <strong>hey(at)algolia.com</strong>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/05/14/jsonp-still-mandatory/">
        Why JSONP is still Mandatory
      </a>
    </h1>

    <span class="post-date">14 May 2014</span>

    <p>At Algolia, we are convinced that search queries need to be sent directly from
the browser (or mobile app) to the search-engine in order to have a realtime
search experience. This is why we have developed a search backend that replies
within a few milliseconds through an API that <a href="http://blog.algolia.com/handle-security-realtime-search/">handles
security</a> when
called from the browser.</p>

<h2>Cross domain requests</h2>

<p>For security reasons, the default behavior of a web browser is to block all
queries that are going to a domain that is different from the website they are
sent from. So when using an external HTTP-based search API, all your queries
should be blocked because they are sent to an external domain. There are two
methods to call an external API from the browser:</p>

<h3> JSONP</h3>

<p>The <a href="http://en.wikipedia.org/wiki/JSONP">JSONP</a> approach is a workaround that
consists of calling an external API  with a DOM <code>&lt;script&gt;</code>  tag. The <code>&lt;script&gt;</code>
tag is allowed to load content from any domains without security restrictions.
The targeted API needs to expose a HTTP GET endpoint and return Javascript
code instead of the regular JSON data. You can use this jQuery code to
dynamically call a JSONP URL:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span> <span class="s2">&quot;http://api.algolia.io/1/indexes/users?query=test&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">data</span> <span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>
</code></pre></div>
<p>In order to retrieve the API answer from the newly included JavaScript code,
jQuery automatically appends a callback argument to your URL (for example
&amp;callback=method12 ) which must be called by the JavaScript code that your API
generates.</p>

<p>This is what a regular JSON reply would look like:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;results&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="err">...</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>
<p>Instead, the JSONP-compliant API generates:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">method12</span><span class="p">({</span><span class="s2">&quot;results&quot;</span><span class="o">:</span> <span class="p">[</span> <span class="p">...]});</span>
</code></pre></div>
<h3>Cross Origin Resource Sharing</h3>

<p><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> (Cross
Origin Resource Sharing) is the proper approach to perform a call to an
external domain. If the remote API is CORS-compliant, you can use a regular
XMLHttpRequest  JavaScript object to perform the API call. In practice the
browser will first perform an HTTP OPTIONS request to the remote API to check
which caller domains are allowed and if it is authorized to execute the
requested URL.</p>

<p>For example here is a CORS request issued by a browser. The most important
lines are the last two headers that specify which permissions are checked. In
this case, the method is POST and the three specific HTTP headers that are
requested.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>OPTIONS http://latency.algolia.io/1/indexes/*/queries
&gt; Host: latency.algolia.io
&gt; Origin: http://demos.algolia.com
&gt; Accept-Encoding: gzip,deflate,sdch
&gt; Accept-Language: en-US,en;q=0.8,fr;q=0.6
&gt; User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2)
&gt; Accept: */*
&gt; Referer: http://demos.algolia.com/eventbrite/
&gt; Connection: keep-alive
&gt; Access-Control-Request-Headers: x-algolia-api-key, x-algolia-application-id, content-type
&gt; Access-Control-Request-Method: POST
</code></pre></div>
<p>The server reply will be similar to this one:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>&lt; HTTP/1.1 200 OK
&lt; Server: nginx/1.6.0
&lt; Date: Tue, 13 May 2014 08:33:55 GMT
&lt; Content-Type: text/plain
&lt; Content-Length: 0
&lt; Connection: keep-alive
&lt; Access-Control-Allow-Origin: *
&lt; Access-Control-Allow-Methods: GET, PUT, DELETE, POST, OPTIONS
&lt; Access-Control-Allow-Headers: x-algolia-api-key, x-algolia-application-id, content-type
&lt; Access-Control-Allow-Credentials: false &lt; Expires: Wed, 14 May 2014 08:33:55 GMT
&lt; Cache-Control: max-age=86400
&lt; Access-Control-Max-Age: 86400
</code></pre></div>
<p>This answer indicates that this POST method can be called from any domain
(Access-Control-Allow-Origin: * ) and with the requested headers.</p>

<p>CORS has many advantages. First, it allows access to a real REST API with all
HTTP verbs (mainly GET, POST, PUT, DELETE) and it also allows to better handle
errors in an API (bad requests, object not found, ...). The major drawback is
that it is only supported by modern browsers (Internet Explorer ≥ 10, Firefox
≥ 3.5, Chrome ≥ 3, Safari ≥ 4 &amp; Opera ≥ 12; Internet Explorer 8 &amp; 9 provides
partial support via theXDomainRequest  object).</p>

<h2>Our initial conclusion</h2>

<p>Because of the advantages of CORS in terms of error handling, we started with
a CORS implementation of our API. We also added a specific support for
Internet Explorer 8 &amp; 9 using the  XDomainRequest  JavaScript object (they do
not support XMLHttpRequest). The main difference is that XDomainRequest  does
not support HTTP headers so we added another way to specify user credentials
in the body of the POST request (it was initially only supported via HTTP
headers).</p>

<p>We were confident that we were supporting almost all browsers with this
implementation, as only very old browsers could cause problems. But we were
wrong!</p>

<h2>CORS problems</h2>

<p>The reality is that CORS still causes problems, even with modern browsers. The
biggest problem we have found was with some firewalls/proxies that refuse HTTP
OPTIONS queries. We even found software on some computers that were blocking
CORS requests, as the <a href="http://www.bennadel.com/blog/2559-cisco-anyconnect-vpn-client-may-%0Ablock-cors-ajax-options-requests.htm">Cisco AnyConnect VPN
client</a>, which is widely used in the enterprise
world. We have found this issue when a TechCrunch employee was not able to
operate search on <a href="http://www.crunchbase.com">crunchbase.com</a> because the
AnyConnect VPN client was installed on his laptop.</p>

<p>Even in 2014 with a large majority of browsers supporting CORS, it is not
possible to have perfect service quality with a CORS-enabled REST API!</p>

<h2>The solution</h2>

<p>Using JSONP is the only solution to ensure great compatibility with old
browsers and handle problems with a misconfigured firewall/proxy. However,
CORS offers the advantage of proper error-handling, so we do not want to limit
ourselves to JSONP.</p>

<p>In the latest version of our JavaScript client, we decided to use CORS with a
fallback on JSONP. At client initialization time, we check if the browser
supports CORS and then perform an OPTIONS query to check that there is no
firewall/proxy that blocks CORS requests. If there is any error we fallback on
JSONP. All this logic is available in our JavaScript client without any
API/code change for our customers.</p>

<p>Having CORS support with automatic fallback on JSONP is the best way we have
found to ensure great service quality and to support all corner case
scenarios. If you see any other way to do it, your feedback is very welcome.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/05/02/inside-growthhackers-implementation-of-algolia/">
        Inside GrowthHackers.com's Implementation of Algolia
      </a>
    </h1>

    <span class="post-date">02 May 2014</span>

    <p>We interviewed <a href="https://twitter.com/dylanLaCom">Dylan La Com</a>, Growth Product
Manager at <a href="https://qualaroo.com">Qualaroo</a> &amp;
<a href="http://growthhackers.com">GrowthHackers.com</a>, about their Algolia
implementation experience.</p>

<p><a href="https://blog.algolia.com/wp-%0Acontent/uploads/2014/05/growthacker.jpg"><img src="/algoliasearch-jekyll-hyde/assets/growthacker.jpg" alt="growthacker"></a></p>

<h3>What role did search play at GrowthHackers before the Algolia</h3>

<p>implementation?</p>

<p>When we launched our community site
<a href="http://growthhackers.com/">GrowthHackers.com</a> in October 2013, search was
admittedly an afterthought for us. GrowthHackers is a social-voting site where
marketers, founders, and product-people can share and discuss growth-related
content. At launch, it was unclear what role search would have on the site.
GrowthHackers is built on Wordpress, and with that comes Wordpress&#39; standard
search functionality. What WP search does is append an additional keyword or
phrase parameter to its typical post query and load a new page with the
results. WP search only indexed the outbound URLs of the articles our members
submitted, and this made finding specific content difficult.</p>

<h3>Why did you want to give search an update on GrowthHackers?</h3>

<p>We started hearing about our lack of a solid search feature from some of our
more active users. One of our members even put together a slide presentation
to prove just how useless our search was [<a href="http://www.slideshare.net/andrewmatthewthompson/improving-search-on-growthhackers">check it out
here</a>]. At the same time, GrowthHackers was becoming more than just a
way to stay up-to-date on the best growth articles, it was becoming the place
to get answers: an encyclopedia for growth-related information. Search volume
at this time was peaking in the mid-hundreds per week. We needed a search
feature that could support this evolving use-case.</p>

<h3>Why did you choose Algolia?</h3>

<p>We looked at several search solutions before trying Algolia, including
Swiftype, WP Search (plugin), and Srch2. All are great solutions, but
ultimately, we went with Algolia because they had the right mix of features:
Their integration was simple, the documentation was thorough, and there were
plenty of starter templates. I knew it was a good sign when, while looking
their GitHub repository, I found they had a demo site built with search that
worked very similar to how we hoped ours would work, complete with real-time
results, typo-tolerance, and filters. The Algolia team was incredibly helpful
getting us set up and was there each step of the way through the integration
process, providing resources and best practices for creating a truly top-notch
search experience.</p>

<h3>Tell me a little about how the new search works.</h3>

<p>Our primary use of Algolia is to store and index user submitted content, and
provide real-time search in our growing database of growth-related articles,
questions, videos and slides. The majority of what we index is article titles
and URLs--strings which are generally small. Visitors to our site often come
with specific growth-related questions and use our search to find answers
quickly. For example, someone interested in learning best practices for
running Twitter ads could type in &quot;Twitter ad&quot; and within milliseconds see
dozens of articles and discussions related to maximizing ROI for Twitter ads.
Using Algolia&#39;s admin dashboard, we&#39;re able to set ranking priorities based on
the number of votes and comments of each article, and make sure the top
results are the most relevant. So, the visitor who searches &quot;Twitter ad&quot; is
shown articles with the highest mix of votes and comments. Algolia took the
search ranking process and wrapped it in a clean and simple interface that
allows anyone, regardless of their experience with search, to easily adjust
and manipulate.</p>

<p>One of the challenges we faced during the integration process was
understanding how to keep our main database synced and up to date with our
Algolia index. User submitted content on GrowthHackers changes often as users
interact with the content. Each post once submitted may receive upvotes and
comments from members in the community. Each post also has a wiki-style
summary field that can be edited by community members. Lastly, posts can have
several states, including published, pending and trashed. In order to ensure
our content on Algolia mirrored the content in our database, we set up a job
queue and a cron process to periodically push updates to our Algolia index.
This has been working quite well for us.</p>

<h3>How has the new search impacted engagement?</h3>

<p>We released the new search mid-February, and since the release we&#39;ve seen
search volume increase 4-5X. Of course there are several factors at play here,
including increased traffic volume and better search bar placement, but it is
clear that Algolia&#39;s search features have contributed to an impressive
increase in search engagement. On average, visitors who utilize search view
2-3X more pages per session and spend 5-6X longer on the site than those who
don&#39;t search. Algolia&#39;s analytics dashboard provides us with an incredible
glimpse of visitor intent on our site by showing us the queries visitors are
searching for, and trend lines to show popularity over time. With this data,
we&#39;re able to better understand how our visitors want to use our site, and
make better decisions about how to organize the content.</p>

<p>Moving forward, we&#39;re hoping to implement Algolia&#39;s search filters to provide
even better ways to access content on our site. We&#39;re excited to have such a
powerful tool in our stack and hope to experiment with new ways to provide
search functionality throughout GrowthHackers.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/04/09/dealing-openssl-security-issue/">
        Dealing with OpenSSL Heartbleed Vulnerability
      </a>
    </h1>

    <span class="post-date">09 Apr 2014</span>

    <p>Yesterday, the OpenSSL project released an update to fix a serious security
issue. This vulnerability was disclosed in <a href="https://web.nvd.nis%0At.gov/view/vuln/detail?vulnId=CVE-2014-0160">CVE-2014-0160</a> and is more widely known as the
<a href="http://heartbleed.com/">Heartbleed vulnerability</a>. It allows an attacker to
grab the content in memory on a server. Given the widespread use of OpenSSL
and the versions affected, this vulnerability affects a large percentage of
services on the internet.</p>

<p>Once the exploit was revealed, we responded immediately: All Algolia services
were secured the same day, by 3pm PDT on Monday, April 7th. The fix was
applied on all our API servers and our website. We then generated new SSL
certificates with a new private key.</p>

<p>Our website is also dependent on Amazon Elastic Load Balance, which was
affected by this issue and <a href="http://aws.amazon.com/security/security-%0Abulletins/aws-services-updated-to-address-openssl-vulnerability/">updated</a> later on
Tuesday, April 8th. We then changed the website certificate.</p>

<p><strong>All Algolia servers are no longer exposed to this vulnerability.</strong></p>

<h2>Your credentials</h2>

<p>We took the time to analyze the past activity on our servers and did not find
any suspicious activity. We are confident that no credentials were leaked.
However, given that this exploit existed in the wild for such a long time, it
is possible that an attacker could have stolen API keys or passwords without
our knowledge. As a result, we recommend that all Algolia users change the
passwords on their accounts. We also recommend that you reset your Algolia
administration API key, which you can do at the bottom of the &quot;Credential&quot;
section in your dashboard. Be careful to update it everywhere you use it in
your code (once you have patched your SSL library if you too are vulnerable).</p>

<h2>Security at Algolia</h2>

<p>The safety and security of our customer data are our highest priorities. We
are continuing to monitor the situation and will respond rapidly to any other
potential threats that may be discovered.</p>

<p>If you have any questions or concerns, please email us directly at
<a href="mailto:security@algolia.com">security@algolia.com</a></p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/stfclv.github.io/page6">Older</a>
  
  
    
      <a class="pagination-item newer" href="/stfclv.github.io/page4">Newer</a>
    
  
</div>
</div>

      <div class="algolia__search-content js-algolia__search-content">
        <h1 class="page-title">Search</h1>
        <div class="posts algolia__results"></div>
      </div>
    </div>

  <script>
  window.ALGOLIA_CONFIG = {
    'applicationId': 'Y467AE5IQA',
    'indexName': 'jekyll_stfclv.github.io',
    'apiKey': '',
    'baseurl': '/stfclv.github.io'
  }
</script>
<script id="algolia__template" type="text/template">

  <div class="algolia__result">
    <a class="algolia__result-link" href="{{ full_url }}#algolia:{{ css_selector }}">{{{ _highlightResult.title.value }}}</a>
    {{#posted_at}}
    <div class="algolia__result-date">{{ posted_at_readable }}</div>
    {{/posted_at}}
    <div class="algolia__result-text">{{{ _highlightResult.text.value }}}</div>
  </div>

</script>
<script id="algolia__template--no-results" type="text/template">
  No results found.
</script>
<script src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch/3.6.0/algoliasearch.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch.helper/2.1.0/algoliasearch.helper.min.js"></script>
<script src="//cdn.jsdelivr.net/hogan.js/3.0.2/hogan.min.js"></script>
<script src="//cdn.jsdelivr.net/momentjs/2.10.3/moment.min.js"></script>
<script src="/stfclv.github.io/public/js/algolia.js"></script>

  </body>
</html>
