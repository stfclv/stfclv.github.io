<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      stf &bull; out &middot; KB with instant search
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/stfclv.github.io/public/css/poole.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/syntax.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/hyde.css">
  <link rel="stylesheet" href="/stfclv.github.io/public/css/algolia.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/stfclv.github.io/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/stfclv.github.io/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-08">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/stfclv.github.io/">
          stf &bull; out
        </a>
      </h1>
      <p class="lead">My personal knowledge base, blog notes and thoughts on top of the popular <a href="http://hyde.getpoole.com/" target="_blank">Hyde</a> &hearts; <a href="http://jekyllrb.com" target="_blank">Jekyll</a>. Made by <a href="https://twitter.com/stefun_" target="_blank">@stefun_</a>, Solutions Architect <a href="http://www.cloudera.com" target="_blank">@Cloudera</a>.</a></p>
    </div>

    <input type="text" class="algolia__input js-algolia__input" autocomplete="off" name="query" placeholder="Search in this site..." />

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/stfclv.github.io/">Home</a>

      

      
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/security/">Security</a>
          
        
      
        
          
          <a class="sidebar-nav-item" href="/stfclv.github.io/tricks/">Trixx</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/stfclv/stfclv.github.io">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2018. All rights reserved. Original by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> and <a href="https://www.algolia.com/" target="_blank">Algolia</a>.</p>
  </div>
</div>


    <div class="content container">
      <div class="algolia__initial-content js-algolia__initial-content"><div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/03/29/introducing-algolias-search-analytics/">
        Introducing Search Analytics: Know Your Users Better
      </a>
    </h1>

    <span class="post-date">29 Mar 2014</span>

    <p>This week we have released a much requested feature by our customers:
analytics.</p>

<h3>The importance of analytics to search</h3>

<p>At Algolia, our goal is to revolutionize the way people search and access
content inside the Web and mobile services. Think about Spotify, LinkedIn,
Amazon: Everyone wants to find the right songs, people and products in just a
couple keystrokes. Our challenge is to provide fast and meaningful access to
all of this content via a simple search box. In March, we answered more than
200 million user queries for our customers on every continent.</p>

<p>Providing the right content through the right search and browsing experience
is key. For our customers, understanding their users - what they like, what
they want and when they want it -  is just as important, if not more. This is
why we came up with this new analytics section, built on top of our API and
available on our customers&#39; online dashboards when they log in to their
Algolia account. So what exactly do we track for you?</p>

<p>We describe here some of the top features that are now available to all our
users.</p>

<h3>Most popular queries</h3>

<p>In this chart, we show which items were most queried. It would be useful, for
example, to a procurement department for anticipating their  most frequently-
searched products&#39; inventory needs. And if you monetize your service through
advertising, know what people are most interested in is especially valuable.</p>

<p>A new analytics feature supports the most popular queries.</p>

<h3>Queries with no or a few results</h3>

<p>Today, most services are simply clueless when it comes to what is missing in
their content base. How do you know that your catalogue of products fits your
users&#39; expectations? Knowing whether or not you provide what your users need
is critical for your business.</p>

<p><a href="https://blog.algolia.com/wp-content/uploads/2014/03/Top-search.png"><img src="/algoliasearch-jekyll-hyde/assets/Top-search-1024x409.png" alt="Search Analytics: Track top queries"></a> Algolia lets you determine which top queries have few or
nonexistent results.</p>

<h3>How does a query evolve over time?</h3>

<p>Is Chanel more popular than Louis Vuitton in the morning or at night? Are
bikes more popular in June or in December? With this new feature, you can now
answer such questions for your own content by following the number of times a
specific query is typed on an hourly basis.</p>

<p><img src="/algoliasearch-jekyll-hyde/assets/Trend%20Louboutin.png" alt="Search Analytics: Track
popularity of a search query over
time"> Example: Search
analytics lets you track the evolution of the query &quot;louboutin&quot; over 24
hours.</p>

<h3>Which categories do people search the most?</h3>

<p>When users type in a query, they often use categories to refine the results.
We let you know which categories were the most frequently used for refinement.
We even provide the most used combinations of categories (such as &quot;dress&quot; +
&quot;blue&quot; + &quot;size M&quot;). It should help you understand how your users browse your
content and has broader implications if the ergonomics of your app is
optimized.</p>

<p><img src="/algoliasearch-jekyll-hyde/assets/Top%20categories.png" alt="Search Analytics: Top categories used for filtering an
refinement"> Track which
combinations of categories people search for the most.</p>

<p>These new analytics features are included in our existing plans at no extra
cost. The number of days when our analytics tools are available vary based on
the plan you choose. We hope you will like it, and we will be more than happy
to read your feedback and feature requests!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/03/25/hipchats-blog-algolia-extends-hipchat-customer-support/">
        On HipChat's blog: Algolia extends HipChat to customer support
      </a>
    </h1>

    <span class="post-date">25 Mar 2014</span>

    <p>As you may probably know, we&#39;re using HipChat to build our live-help chat. If
you want to know more, go ahead and read our <a href="http://blog.hipchat.com/2014/03/25/algolia-extends-hipchat-to-customer-support/">guest post on HipChat&#39;s
blog</a>.</p>

<p><a href="http://blog.hipchat.com/2014/03/25/algolia-extends-hipchat-to-customer-support/"><img src="/algoliasearch-jekyll-hyde/assets/Divided%20screen%20hipchat%20algolia.png" alt="Hipchat: Live help chat."></a></p>

<p>Algolia uses HipChat to
provide live customer service over chat.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/03/18/handle-security-realtime-search/">
        Realtime Search: Security and our Javascript Client
      </a>
    </h1>

    <span class="post-date">18 Mar 2014</span>

    <p><em><strong>Edit: As suggested on <a href="https://news.ycombinator.com/item?id=7419205">Hacker
News</a>, SHA256 is not secure, as
it allows a length extension attack. We have replaced it with HMAC-SHA256.</strong></em></p>

<p>Instant is in our DNA, so our first priority was to build a search backend
that would be able to return relevant realtime search results in a few
milliseconds. However, the backend is just one variable in our realtime
equation. The response time perceived by the end user is the total lapse of
time between their first keystroke and the final display of their results.
Thus, with an extremely fast backend, solving this equation comes down to
optimising network latency. This is an issue we solve in two steps:</p>

<ul>
<li>First, we have <a href="http://blog.algolia.com/added-asian-datacenter-offer/">datacenters in three different locations</a>, allowing us to answer queries in North America, Europe and Asia in less than 100ms (including search computation).</li>
<li>Second, to keep reducing this perceived latency, queries must be sent directly from the end users&#39; browsers or mobile phones to our servers. To avoid intermediaries like your own servers, we offer a JavaScript client for websites and ObjC/Android/C# clients for mobile apps.</li>
</ul>

<h2>The security challenge of JavaScript</h2>

<p>Using this client means that you need to include an API key in your JavaScript
(or mobile app) code. The first security issue with this approach is that this
key can be easily retrieved by anyone who simply looks at the code of the
page. This gives that person the potential to modify the content behind the
website/mobile application! To fix this problem, we provide search-only API
keys which protect your indexes from unauthorized modifications.</p>

<p>This was a first step and we&#39;ve quickly had to solve two other security
issues:</p>

<ul>
<li>*<em>Limiting the ability to crawl your data: *</em>you may not want people to get all your data by continuous querying. The simple solution was to limit the number of API calls a user could perform in a given period of time. We implemented this by setting a rate limit per IP address. However, this approach is not acceptable if a lot of users are behind a global firewall, thus sharing one IP address. This is very likely for our corporate users.</li>
<li><strong>Securing access control</strong>:  you may need to restrict the queries of a user to specific content. For example, you may have power users who should get access to more content than &quot;regular&quot; users. The easy way to do it is by using filters. The problem here with simple filters in your JavaScript code is that people can figure out how to modify these filters and get access to content they are not be supposed to see.</li>
</ul>

<h2>How we solve it altogether</h2>

<p>Today, most websites and applications require people to create an account and
log in to access a personalized experience (think of CRM applications,
Facebook or even Netflix). We decided to use these user IDs to solve these two
issues by creating signed API keys. Let&#39;s say you have an API key with search
only permission and want to apply a filter on two groups of content (public OR
power<em>users</em>only) for a specific user (id=42):</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>api_key=20ffce3fdbf036db955d67645bb2c993
query_filters=(public,power_users_only)
user_token=42
</code></pre></div>
<p>You can generate a secured API key in your backend that is defined by a hash
(HMAC SHA 256) of three elements:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>secured_api_key=HMAC_SHA_256(api_key, query_filters + user_token)
secured_api_key=HMAC_SHA_256(&quot;20ffce3fdbf036db955d67645bb2c993&quot;, &quot;(public,power_users_only)&quot; + &quot;42&quot;)
secured_api_key=&quot;3abb95c273455ce9b57c61ee5258ba44093f17022dd4bfb39a37e56bee7d24a5&quot;
</code></pre></div>
<p>For example, if you are using rails, the code in your backend would be:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>secured_key = Algolia.generate_secured_api_key(&#39;20ffce3fdbf036db955d67645bb2c993&#39;, &#39;(public,power_users_only)&#39;, &#39;42&#39;)
</code></pre></div>
<p>You can then initialize your JavaScript code with the secured API key and
associated information:</p>

<p>The user identifier (defined by SetUserToken) is used instead of the IP
address for the rate limit and the security filters (defined by
SetSecurityTags) are automatically applied to the query.</p>

<p>In practice, if a user wants to overstep her rights, she will need to modify
her security tags and figure out the new hash. Our backend checks if a query
is legit by computing all the possible hashes using all your available API
keys for the queried index, as well as the security tags defined in the query
and the user identifier (if set).  If there is no match between the hash of
the query and the ones we computed, we will return a permission denied (403).
Don&#39;t worry, reverse-engineering the original API key using brute-force would
require years and <a href="http://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions">thousands of
core</a>.</p>

<p>You may want to apply security filters without limiting the rate of queries,
so if you don&#39;t need both of these features, you can use only one.</p>

<p>We launched this new feature a few weeks ago and we have received very good
feedback so far. Our customers don&#39;t need to choose anymore between security
and realtime search. If you see any way to improve this approach, we would
love to hear your feedback!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/03/17/caused-todays-performance-issues-europe-will-happen/">
        What Caused Today's Search Performance Issues In Europe and Why It Will Not Happen Again
      </a>
    </h1>

    <span class="post-date">17 Mar 2014</span>

    <p>During a few hours on March 17th you may have noticed longer response times
for some of the queries sent by your users.</p>

<p><img src="/algoliasearch-jekyll-hyde/assets/slowerthanaverage.png" alt="Slower than average search
performance"></p>

<p><em>Average latency for one of our European clusters on March 17th</em></p>

<p>As you can see above, our slowest average response time (measured from the
user&#39;s browser to our servers and back to the user&#39;s browser) on one of our
European clusters peaked at 858ms. On a normal day, this peak is usually no
higher than 55ms.</p>

<p>This was clearly not a normal behavior for our API, so we investigated.</p>

<h2>How indexing and search calls share the resource</h2>

<p>Each cluster handles two kinds of calls on our REST API: the ones to build and
modify the indexes (Writes) and the ones to answer users&#39; queries (Search).
The resources of each cluster are shared between these two uses. As Write
operations are far more expensive than Search calls, we designed our API so
that indexing should never use more than 10% of these resources.</p>

<p>Up until now, we used to set a limitation on the rate of Writes <em>per HTTP
connection</em>. There was no such limit for queries (Search); We simply limited
Write calls to keep search quality. To avoid reaching the Write rate limit too
quickly, we recommended users to Write by batching up to 1GB of operations per
call, rather than sending them one by one. (A batch, for example, could be
adding 1M products to an index on a single network call.) A loophole in this
recommendation was the origin of yesterday&#39;s issues.</p>

<p>What happened yesterday is that on one of our European clusters, one customer
pushed so many unbatched indexing calls from different HTTP connections that
they massively outnumbered the search calls of the other users on the cluster.</p>

<p>This eventually slowed down the average response time for the queries on this
cluster, impacting our usual search performance.</p>

<h2>The Solution</h2>

<p>As of today, we now set the rate limit of Writes <em>per account</em> and not per
HTTP connection. It prevents anyone from using multiple connections to bypass
this Write rate limit. This also implies that customers who want to push a lot
of operations in a short time simply need to send their calls in batches.</p>

<p>How would you batch your calls? The explanation is in our documentation. See
here for an example with our Ruby client: <a href="https://github.com/algolia%0A/algoliasearch-client-ruby#batch-writes">https://github.com/algolia
/algoliasearch-client-ruby#batch-writes</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/stfclv.github.io/2014/03/15/algolia-heroku-add-on-enters-ga/">
        Algolia Heroku add-on enters general availability
      </a>
    </h1>

    <span class="post-date">15 Mar 2014</span>

    <p>We launched the first beta of our Heroku add-on in October 2013 and are now
happy to announce its general availability!</p>

<p>During the beta period we received excellent feedback (and some bug reports!)
that helped us improve our integration. We are now fully ready to serve
production on both Heroku datacenters. If you were part of our beta program,
we will contact you shortly to invite you to migrate to a standard plan.</p>

<p>You can directly install it from our <a href="https://addons.heroku.com/algoliasearch">Heroku add-on
page</a> and as ever, please <a href="mailto:hey@algolia.com">let us
know</a> if you have any feedback!</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/stfclv.github.io/page7">Older</a>
  
  
    
      <a class="pagination-item newer" href="/stfclv.github.io/page5">Newer</a>
    
  
</div>
</div>

      <div class="algolia__search-content js-algolia__search-content">
        <h1 class="page-title">Search</h1>
        <div class="posts algolia__results"></div>
      </div>
    </div>

  <script>
  window.ALGOLIA_CONFIG = {
    'applicationId': 'Y467AE5IQA',
    'indexName': 'jekyll_stfclv.github.io',
    'apiKey': '',
    'baseurl': '/stfclv.github.io'
  }
</script>
<script id="algolia__template" type="text/template">

  <div class="algolia__result">
    <a class="algolia__result-link" href="{{ full_url }}#algolia:{{ css_selector }}">{{{ _highlightResult.title.value }}}</a>
    {{#posted_at}}
    <div class="algolia__result-date">{{ posted_at_readable }}</div>
    {{/posted_at}}
    <div class="algolia__result-text">{{{ _highlightResult.text.value }}}</div>
  </div>

</script>
<script id="algolia__template--no-results" type="text/template">
  No results found.
</script>
<script src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch/3.6.0/algoliasearch.min.js"></script>
<script src="//cdn.jsdelivr.net/algoliasearch.helper/2.1.0/algoliasearch.helper.min.js"></script>
<script src="//cdn.jsdelivr.net/hogan.js/3.0.2/hogan.min.js"></script>
<script src="//cdn.jsdelivr.net/momentjs/2.10.3/moment.min.js"></script>
<script src="/stfclv.github.io/public/js/algolia.js"></script>

  </body>
</html>
